---
title: 组件化框架
author: nate_fu
date: 2021-08-25
category: Jekyll
layout: post
---





# 组件化框架
## 背景
&emsp;&emsp;伴随着APP端项目的发展，业务逻辑日趋复杂，项目模块耦合严重。频繁的需求迭代使得重复造车代码冗余现象严重。传统的开发方式存在诸多弊端，已经不再使用当前的业务环境。因此需要新的思想设计新的框架从而满足需求的支撑。
## 问题
*  解决重复造车代码冗余的问题
*  解决代码耦合严重的问题
## 框架描述
&emsp;&emsp;首先在日常开发中会发现业务需求在UI界面上的效果展示方式存在共通性。比如说APP 设计主页面多数选择底部按钮 Tab切换的方式。只不过按钮数量样式不同。再比如说首页模块的入口比较多的情况下会采用九宫格的设计方式。或者相同一类数据的展示会采用列表来展示等等。而不同的是设计上样式风格会有所不同。**如果说能够统一样式风格或者说做到相对灵活的样式就可以将页面封装成一个个组件**，然后在页面开发过程中不需要花过多的时间进行页面的开发，只需要引用对应的组件然后刷新新的数据就可以直接组成一个新的页面。从而解决重复造车的问题。  
&emsp;&emsp;另外传统开发中业务模块之间相互依赖，从而可以进行信息的传递，举个例子A模块中有个按钮点击挑战到B模块并且把A中的数据传递给B显示，那就需要在A中创建B的对象同时调用B的方法，可能B中有很多方法，被其他 CDE等调用，那一天B下线了。我们就需要对ACDE都进行修改 牵一发动全身。因此需要解耦。让模块相互独立。互不干扰。**消息的传递需要通过事件分发来的消息机制实现不能依赖于类来实现**
## 架构
![Image](module.png)  
图中所示组件继承自共同的父类但彼此之间不存在依赖关系，相互独立。然后组件组合在一起形成一个个的页面，页面构成我们的app。  

![Image](activity_UI.png)   
如图所示将页面划分成几块区域然后在布局中创建容器对象。每个容器对应一个ID,然后创建组件对象与容器ID 相关联。在页面初始化的时候直接用容器加载组件。从而组成一个完整的界面。  

&emsp;&emsp;如此一来封装好的组件不断的各自搭配就可以形成一个个不同的界面。从而就不需要不断的去重新开发页面，提高了开发效率。  
## 类结构设计
![Image](组件类结构图.png)  
&emsp;&emsp;按照架构的设计思想，一个activity 或者 fragment 页面是一个大的业务模块，而大的业务模块又是由小的业务组合起来。将小的业务分割成一个个的组件module来进行管理。因此需要注意  

1. 大的业务模块依赖小的业务模块，也就是说 activity 或者fragment 依赖于 module 同时 module 是由 activity 或者 fragment 创建。  
2. 小的业务模块有自己的生命周期，但是小的业务模块的生命周期必须依附于大的业务模块的生命周期，不能超过大的业务模块的生命周期。
3. 小的业务模块不能依赖大的业务模块，小业务模块之间也没有相互依赖。是彼此隔离的。  

&emsp;&emsp;按照上面的设计思想，我们看设计的类结构图 大的业务模块也就是activity 或者fragment。同时设计了ModuleManager类来管理 module 的生命周期，当 activity 或者fragment的生命周期发生变化后 会通知module 发生相应的变化。然后创建了子类ActivityManager 和 FragmentManager 类来分别为 Activity和Fragment服务。  
&emsp;&emsp;管理类和大的业务类是组合关系，代表着大业务的其中一种功能，另外管理类还和Module 的抽象父类存在关联关系 **（一种比依赖更强的关系）** ，也就是大业务类依赖小业务类。同时 module 之间只有继承相同的父类，彼此之间不存在任何关系。是相互隔离的。module也不存在对activity 或者 fragment 的依赖关系。
&emsp;&emsp;另外就是工厂类ModuleFactory。组件工厂就是通过组件的名称创建组件module对象。因此activity 或者fragment创建组件时是依赖 ModuleFactory这个类的。  
## 主要的类代码实现
### ModuleContext.java
```java
/**
 * @author by nate_fu on 2020-10-12.
 * <p>
 * Email: fuyonghui@zjhcsoft.com
 * @version vision 1.0
 * <p>
 * description:组件上下文。保存activity 传递的参数
 */
public class ModuleContext {
    /**
     * 上下文
     */
    private Activity context;
    /**
     * 参数数据
     */
    private Bundle saveInstance;
    /**
     * 容器视图
     */
    private ViewGroup parentView;
}

```  
> ModuleContext 用来保存页面的信息并传递给组件使用。viewGroups用来保存整个页面的组件容器。

### ModuleManager.java
```java
/**
 * @author by nate_fu on 2020-10-12.
 * <p>
 * Email: fuyonghui@zjhcsoft.com
 * @version vision 1.0
 * <p>
 * description:
 */
public class ModuleManager {
     /**
     * 组件名字和 布局ID 绑定
     */
    private ArrayMap<Integer, String> modules = new ArrayMap<>();
    /**
     * 组件对象集合
     */
    protected ArrayMap<Integer,AbstractModule> allModules = new ArrayMap<>();

    
   /**
     * 配置组件
     * @param modules
     */
    public void moduleConfig(ArrayMap<Integer, String> modules) {
        this.modules = modules;
    }

    /**
     * 生命周期
     * onResume
     */
    public void onResume(){
        for (AbstractModule module:allModules.values()) {
            if (module != null) {
                module.onResume();
            }
        }
    }
    /**
     * 生命周期
     * onPause
     */
    public void onPause(){
        for (AbstractModule module:allModules.values()) {
            if (module != null) {
                module.onPause();
            }
        }
    }
    /**
     * 生命周期
     * onStop
     */
    public void onStop(){
        for (AbstractModule module:allModules.values()) {
            if (module != null) {
                module.onStop();
            }
        }
    }
    public void onConfigurationChanged(Configuration newConfig){
        for (AbstractModule module:allModules.values()) {
            if (module != null) {
                module.onOrientationChanges(newConfig.orientation == Configuration.ORIENTATION_LANDSCAPE);
            }
        }
    }
    /**
     * 生命周期
     * onDestroy
     */
    public void onDestroy(){
        handler = null;
        pool = null;
        for (AbstractModule module:allModules.values()) {
            if (module != null) {
                module.onDestroy();
            }
        }
    }
}
``` 
> 页面通过组件管理类来管理页面中的一系列组件，关联页面和组件的生命周期，当页面的生命周期发生变化，会调用ModuleManager中相应的方法。然后循环页面中所有的组件触发对应的生命周期，这样就可以控制组件的生命周期在页面的生命周期范围之内。

### ActivityManager.java
```java
/**
 * @author by nate_fu on 2020-10-13.
 * <p>
 * Email: fuyonghui@zjhcsoft.com
 * @version vision 1.0
 * <p>
 * description:
 */
public class ActivityManager extends ModuleManager{
   

     /**
     * 加载组件根据配置加载到视图上
     * @param saveInstance
     * @param activity
     */
    public void initModules(final Bundle saveInstance, final Activity activity){
        if (getModules() ==null){
            return;
        }

        //循环获取组件
        for (int i = 0; i < getModules().size(); i++) {

            final String moduleName = getModules().valueAt(i);
            final Integer mViewId = getModules().keyAt(i);
            if (ModuleUtil.empty(moduleName)){
                return;
            }
            getPool().execute(new Runnable() {
                @Override
                public void run() {
                    //根据组件名字创建组件对象
                    final AbstractModule module = ModuleFactory.newModule(moduleName);
                    if (module!=null) {
                        //创建成功给组件设置上下文
                        final ModuleContext moduleContext =new ModuleContext();
                        moduleContext.setContext(activity);
                        moduleContext.setSaveInstance(saveInstance);
                        //设置父视图
                        ViewGroup parentView =  (ViewGroup)activity.findViewById(mViewId);
                        moduleContext.setParentView(parentView);

                        getHandler().post(new Runnable() {
                            @Override
                            public void run() {
                                module.init(moduleContext,mViewId);
                                allModules.put(mViewId,module);
                            }
                        });
                    }
                }
            });
        }
    }

}
```
> 组件管理类的子类。主要服务于activity页面，在这个类中我们实现组件的创建工作。循环组件的名称，通过名称反射创建组件对象。然后把组件对象添加到allModules数组中进行管理。

### AbstractModule.java
```java
/**
 * @author by nate_fu on 2020-10-12.
 * <p>
 * Email: fuyonghui@zjhcsoft.com
 * @version vision 1.0
 * <p>
 * description:组件的抽象父类。生命周期函数，用来和activity fragment 生命周期挂钩，
 * 当外部容器生命周期发生变化时。组件也应该发生相应的变化
 */
public abstract class AbstractModule {
     /**
     * 初始化组件
     * @param moduleContext
     * @param groupId 组件对应的布局Id
     */
    public abstract void init(ModuleContext moduleContext,int groupId);

    /**
     * 生命周期
     * onSaveInstanceState
     * @param outState
     */
    public abstract void onSaveInstanceState(Bundle outState);

    /**
     * 生命周期
     * onResume
     */
    public abstract void onResume();
    /**
     * 生命周期
     * onPause
     */
    public abstract void onPause();
    /**
     * 生命周期
     * onStop
     */
    public abstract void onStop();

    /**
     * 生命周期
     * onOrientationChanges
     * @param isLandscape
     */
    public abstract void onOrientationChanges(boolean isLandscape);

    /**
     * 生命周期
     * onDestroy
     */
    public abstract void onDestroy();

}
```
> 组件的父类，所有组件都继承这个类，实现对应的方法。
### ModuleFactory.java
```java
/**
 * @author by nate_fu on 2020-10-14.
 * <p>
 * Email: fuyonghui@zjhcsoft.com
 * @version vision 1.0
 * <p>
 * description:
 */
public class ModuleFactory {
    /**
     * 根据组件类名反射创建组件对象
     * @param name
     * @return
     */
    public static AbstractModule newModule(String name){
        if (name ==null || name.equals("")){
            return null;
        }

        try{
            Class<? extends AbstractModule> moduleClazz = (Class<? extends AbstractModule>) Class.forName(name);
            if (moduleClazz !=null){
                AbstractModule instance = (AbstractModule)moduleClazz.newInstance();
                return instance;
            }
            return null;
        }catch (ClassNotFoundException e){
            e.printStackTrace();
        }catch (InstantiationException e){
            e.printStackTrace();
        }catch (IllegalAccessException e){
            e.printStackTrace();
        }
        return null;
    }
}

```
> 组件工厂类，通过一个静态方法通过组件的名称反射创建组件对象。

## 模块解耦
&emsp;&emsp;组件间通信在传统模式下调用方法传递参数的时候需要持有对象的引用，会让模块彼此之间耦合严重，不利于模块的维护。我们可以采用 **发布/订阅模式**让彼此之间解耦。  
![Image](moduleBus.png)
在设计模式中发布订阅模式可以将发布者和订阅者隔离开，如图所示发布者发布消息后消息会进入设计的ModuleBus中，再由ModuleBus将消息分发给订阅者。而ModuleBus就是设计的事件总线机制
* 优点 解耦 轻量级
* 缺点 需要循环遍历方法，造成一定的性能消耗。发送消息的时候无法指定相应的订阅者。  

虽然发布订阅模式具有一定的缺点，但是他能够做到模块之间的完全解耦，这对于组件化框架的设计来说十分重要。  
### 针对无法指定订阅者的解决方案
&emsp;&emsp;因为组件框架的目的就是将业务细分 封装 重复利用，因此很多时候同一个页面有很多相同的组件，但是我们要根据数据的不同来让组件展示不同的效果。当数据刷新时，我们必须刷新指定的组件而不是相同的组件同时刷新，思考到我们组件和页面容器groupView是一一对应的，而groupView 在Android中可以设置唯一的ID。所以我们可以让组件对象持有对应Groupview的Id。在发送者发送事件的时候将对应的组件持有的ID也发送过去，这样就可以指定订阅者发生相应的改变。  
## ModuleBus注册和发送消息流程图
![Image](eventBus流程图.png)
## ModuleBus核心代码实现
### ModuleEvent.java
```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD,ElementType.FIELD})
@Documented
public @interface ModuleEvent {
    /**
     * 方法类型，区分类别
     * @return
     */
    String eventType() default "module";
}
```
利用Java注解标记方法，该注解表示运行时有效。给方法进行注解。运用注解可以方便找出对象中我们需要去执行的方法。
在ModuleBus这个类中首先我们要设置单列，表示中介者有且只有一个。  
```java
 private static volatile ModuleBus instance;


    public static ModuleBus getInstance(){
        if(instance == null){
            synchronized (ModuleBus.class){
                if (instance == null){
                    instance = new ModuleBus();
                }
            }
        }
        return instance;
    }
```
在订阅者创建的时候需要将订阅者注册到ModuleBus中。
```java
 /**
     * 将订阅者对象注册进来
     * @param subscriber
     */
    public void register(Object subscriber){
        if(subscriber == null){
            return;
        }
        Class<?> subscriberClass = subscriber.getClass();
        if(subscriberClass == null){
            return;
        }
        //获取订阅者对象中的方法集合
        Method[] methods = subscriberClass.getMethods();
        //循环遍历被注解标记的方法
        for(Method method:methods){
            ModuleEvent event = method.getAnnotation(ModuleEvent.class);
            if(event !=null){

                String eventType = event.eventType();

                addSubscriber(eventType, subscriber, method);

                addEventMethod(subscriber,method);
            }
        }
    }

```
注册对象的时候会循环对象中的方法，然后找到被注解的方法，再根据注解中的参数将订阅者对象根据eventType，methodName 对应起来存储到ArrayMap 中 在内存中进行管理。同样的我们把对象 和对象方法集合也对应起来 存在ArrayMap中，方便后面使用。
```java
/**
     *
     * @param eventType 订阅对象的类别
     * @param subscriber 订阅对象
     * @param m 方法
     */
    private void addSubscriber(String eventType,Object subscriber,Method m){
        //订阅对象的集合
        ArrayMap<String,ArrayList<Object>> subscriberMethodList = moduleMethodSubscriber.get(eventType);

        if (subscriberMethodList == null) {
            subscriberMethodList = new ArrayMap<>();
        }
        //根据方法名获取拥有这个方法的所有订阅者
        ArrayList<Object> subscriberList = subscriberMethodList.get(m.getName());
        if (subscriberList ==null){
            subscriberList = new ArrayList<>();
        }

        subscriberList.add(subscriber);
        subscriberMethodList.put(m.getName(),subscriberList);
        moduleMethodSubscriber.put(eventType,subscriberMethodList);
    }

    /**
     * 添加方法
     * @param subscriber
     * @param m
     */
    private void addEventMethod(Object subscriber, Method m){
        ArrayMap<String, MethodInfo> methods = moduleEventMethods.get(subscriber);
        if (methods == null) {
            methods = new ArrayMap<>();
            moduleEventMethods.put(subscriber, methods);
        }
        methods.put(m.getName(), new MethodInfo(m.getName(), m));
    }
```
当订阅者对象销毁时，应该将这个订阅者对象和方法从ModuleBus中删除
```java
 /**
     *删除订阅者
     * @param subscriber
     */
    public void unregister(Object subscriber){
        if(subscriber == null){
            return;
        }
        Class<?> subscriberClass = subscriber.getClass();
        if(subscriberClass == null){
            return;
        }
        moduleEventMethods.remove(subscriber);
        Method[] methods = subscriberClass.getMethods();
        for(Method method:methods) {
            ModuleEvent event = method.getAnnotation(ModuleEvent.class);
            if(event !=null) {
                String eventType = event.eventType();
                moduleMethodSubscriber.get(eventType).get(method.getName()).remove(subscriber);
            }
        }
    }
```
发送消息需要传方法名字和参数，根据名字和参数去循环匹配找到对应的订阅者的方法，和订阅者对象，在利用Java反射实现方法的调用。通过这样的方式我们实现了模块之间的解耦。
```java
for(Object c: subscriberList){
                try{
                    ArrayMap<String,MethodInfo> methods = moduleEventMethods.get(c);
                    Method method = methods.get(methodName).m;
                    if(method == null){
                        return;
                    }else if(method.getParameterTypes() == null){
                        return;
                    }else if(method.getParameterTypes().length != args.length){
                        return;
                    }
                    method.invoke(c,args);
                }catch (Throwable e){
                    Log.e(TAG,e.toString());
                }
            }
```
## 总结

&emsp;&emsp;在Android开发过程中，利用gradle 构建工具可以将一个工程文件目录分割成多个library目录，在物理结构上将代码分离，同时利用我们的组件化框架加上ModuleBus消息事件机制可以让工程在代码上解耦分离。从而完全改变我们的开发模式。当我们把小的业务模块一个个封装开发完成，做到足够灵活适配大多少业务场景。那么当新的业务需求需要开发，只需要将页面分割成一个个组件，然后为组件在页面布局上设计好容器，通过框架就可以直接实现页面的创建。同时通过ModuleBus可以将网络请求的数据更新到对应的组件上。开发效率大大提升。





